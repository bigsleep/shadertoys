<!DOCTYPE HTML>
<head>
<meta charset="UTF-8">
<title>shaderviewer</title>
</head>

<body>

<div id="main">
    <label for="shaderSelect">shader</label>
    <select id="shaderSelect">
    </select>

    <label for="textureSelect">texture</label>
    <select id="texture0Select">
    </select>

    <label for="texture0MinFilter">minFilter</label>
    <select id="texture0MinFilter">
        <option value="0">Linear</option>
        <option value="1">Nearest</option>
    </select>

    <label for="texture0MagFilter">magFilter</label>
    <select id="texture0MagFilter">
        <option value="0">Linear</option>
        <option value="1">Nearest</option>
    </select>
    <div id="container"></div>
</div>

<script type="text/javascript" src="jquery-3.2.1.min.js"></script>
<script type="text/javascript" src="three.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">
void main()	{
    gl_Position = vec4(position, 1.0);

}
</script>

<script type="text/javascript">
function init(fragmentShaderUrl, textureUrl) {
    var shaderViewer = {};
    shaderViewer.uniforms = {
        iTime:       { value: 1.0 },
        iResolution: { value: new THREE.Vector2() }
    };

    shaderViewer.buildShaderSrc = function (body) {
        var fragmentShaderPrefix =`
uniform vec2 iResolution;
uniform float iTime;
uniform sampler2D iChannel0;
uniform vec2 iChannel0Size;
`;
        var fragmentShaderPostfix =`
void main()
{
    mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;
        return fragmentShaderPrefix + body + fragmentShaderPostfix;
    };

    shaderViewer.loadFragmentShader = function (shaderUrl) {
        var loader = new THREE.FileLoader();
        loader.mimeType = "x-shader/x-fragment";
        return new Promise(function (resolve) {
            loader.load(shaderUrl, function (content) {
                resolve(shaderViewer.buildShaderSrc(content));
            });
        });
    };

    shaderViewer.loadTexture = function (textureUrl) {
        var loader = new THREE.TextureLoader();
        return new Promise(function (resolve) {
            loader.load(textureUrl, function (texture) {
                resolve(texture);
            });
        });
    };

    shaderViewer.onWindowResize = function (event) {
        shaderViewer.renderer.setSize(500, 281);
        shaderViewer.uniforms.iResolution.value.x = shaderViewer.renderer.domElement.width;
        shaderViewer.uniforms.iResolution.value.y = shaderViewer.renderer.domElement.height;
    };

    var resources = {};
    return shaderViewer
        .loadFragmentShader(fragmentShaderUrl)
        .then(function (fragmentShader) {
            resources.fragmentShader = fragmentShader;
            return shaderViewer.loadTexture(textureUrl)
                .then(function (texture) {
                    return { fragmentShader : fragmentShader, texture0 : texture };
                });
        })
        .then(function (resource) {
            shaderViewer.uniforms.iChannel0 = { type: "t", value: resource.texture0 };
            shaderViewer.uniforms.iChannel0Size = { type: "v2", value: new THREE.Vector2(resource.texture0.image.width, resource.texture0.image.width) };
            var material = new THREE.ShaderMaterial({
                uniforms: shaderViewer.uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: resource.fragmentShader
            });

           shaderViewer.render = function () {
                shaderViewer.uniforms.iTime.value += 0.05;
                shaderViewer.renderer.render(scene, camera);
            };

            shaderViewer.animate = function () {
                requestAnimationFrame(shaderViewer.animate);
                shaderViewer.render();
            };

            shaderViewer.changeShader = function (shaderUrl) {
                shaderViewer.loadFragmentShader(shaderUrl)
                    .then(function (fragmentShader) {
                        material.fragmentShader = fragmentShader;
                        material.needsUpdate = true;
                    });
            };

            shaderViewer.changeTexture = function (textureUrl) {
                shaderViewer.loadTexture(textureUrl)
                    .then(function (texture) {
                        shaderViewer.uniforms.iChannel0.value = texture;
                        shaderViewer.uniforms.iChannel0Size.value = new THREE.Vector2(texture.image.width, texture.image.width);
                    });
            };

            shaderViewer.changeTextureMinFilter = function (filterType) {
                shaderViewer.uniforms.iChannel0.value.minFilter = filterType;
                shaderViewer.uniforms.iChannel0.value.needsUpdate = true;
            };

            shaderViewer.changeTextureMaxFilter = function (filterType) {
                shaderViewer.uniforms.iChannel0.value.magFilter = filterType;
                shaderViewer.uniforms.iChannel0.value.needsUpdate = true;
            };

            camera = new THREE.Camera();
            camera.position.z = 1;
            scene = new THREE.Scene;

            var geometry = new THREE.PlaneBufferGeometry(2, 2);

            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            shaderViewer.renderer = new THREE.WebGLRenderer();
            shaderViewer.renderer.setPixelRatio(window.devicePixelRatio);
            var container = document.getElementById("container");
            container.appendChild(shaderViewer.renderer.domElement);

            shaderViewer.onWindowResize();
            return shaderViewer;
        });
}

var shaderNames =
    [ "circle01.glsl"
    , "wavycircle01.glsl"
    , "wavycircle02.glsl"
    , "perlinnoise01.glsl"
    , "cubic01.glsl"
    , "fragment01.glsl"
    , "texture01.glsl"
    , "vector-distance-field.glsl"
    , "vector-distance-field-bicubic.glsl"
    , "raymarching01.glsl"
    , "raymarching02.glsl"
    ];

var shaderSelect = document.getElementById("shaderSelect");
shaderNames.forEach(function (srcName) {
    var opt = document.createElement('option');
    opt.value = srcName;
    opt.innerHTML = srcName;
    shaderSelect.appendChild(opt);
});

var textureNames =
    [ "circle-distance-field-32.png"
    , "circle-distance-field-64.png"
    , "circle-distance-field-128.png"
    , "low-resolution-circle.png"
    ];

var texture0Select = document.getElementById("texture0Select");
textureNames.forEach(function (srcName) {
    var opt = document.createElement('option');
    opt.value = srcName;
    opt.innerHTML = srcName;
    texture0Select.appendChild(opt);
});

var filterTypes =
    [ THREE.LinearFilter
    , THREE.NearestFilter
    ];

init(shaderNames[0], textureNames[0]).then(function (viewer) {
    $("#shaderSelect").change(function (event) {
        viewer.changeShader(event.target.value);
    });
    $("#texture0Select").change(function (event) {
        viewer.changeTexture(event.target.value);
    });
    $("#texture0MinFilter").change(function (event) {
        viewer.changeTextureMinFilter(filterTypes[event.target.value]);
    });
    $("#texture0MagFilter").change(function (event) {
        viewer.changeTextureMaxFilter(filterTypes[event.target.value]);
    });

    viewer.animate();
});
</script>

<style>
#container {
    width: 500px;
    height: 281px;
    border: solid 1px #000000;
}
</style>
</body>
